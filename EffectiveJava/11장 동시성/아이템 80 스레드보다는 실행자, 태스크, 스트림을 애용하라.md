## Executor Framework
- `java.util.concurrent` 패키지의 `Executor Framework` 를 통해 작업 큐를 간단히 만들 수 있따.
- 생성
  - `ExecutorService exec = Executors.newSingleThreadExecutor();`
- 실행
  - `exec.execute(runnable);`
- 종료
  - `exec.shutdown();`
- 특정 태스크가 완료되기를 기다리는 `get`
- 태스크 모음 중 아무것 하나가 완료되기를 기다리는 `invokeAny`
- 모든 태스크가 완료되기를 기다리는 `invokeAll`
- 실행자 서비스가 종룡하기를 기다리는 `awaitTermination`
- 완료된 태스크들의 결과를 차례로 받는 `ExecutorCompletionService`
- 태스크를 특정 시간에 혹은 주기적으로 실행하게 하는 `ScheduledThreadPoolExecutor`

### Executor 활용
- `java.util.concurrent.Executors` 의 정적 팩터리를 이용해 필요한 실행자를 생성할 수 있다.
- 작은 프로그램이나 가벼운 서버의 경우 `Executors.newCachedThreadPool` 이 좋은 선택이다.
  - 특별한 설정없이 일반적인 용도에 적합하다.
  - `CachedThreadPool` 은 무거운 프로덕션 서버에는 좋지 못하다.
  - `CachedThreadPool` 은 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임되어 실행되며 가용한 스레드가 없다면 새로 생성한다.
  - 때문에 서버가 무거운 경우 CPU 사용률이 올라가고 새로운 태스크마다 다른 스레드를 생성하며 성능이 저하된다.
- 무거운 프로덕션 서버는 스레드 개수를 고정한 `Executors.newFixedThreadPool` 을 선택하거나 `ThreadPoolExecutor` 를 직접 사용하는 편이 낫다.
- 작업 큐 또는 스레드를 직접 다루는 일을 삼가야 한다.
  - 스레드를 직접 다루면 `Thread` 가 작업 단위와 수행 메커니즘 역할을 모두 수행하게 된다.
- 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리된다.
- 태스크는 작업 단위를 나타내는 핵심 추상 개념이다.
- 태스크는 `Runnable` 과 `Callable` 이 있다.
  - `Callable` 은 `Runnable` 과 비슷하지만 값을 반환하고 임의의 예외를 던질 수 있다.
- 태스크를 수행하는 일반적인 메커니즘이 실행자 서비스 이다.
- 태스크 수행을 실행자 서비스에 맡기면 원하는 태스크 수행 정책을 선택할 수 있고, 변경할 수 있다.
- 핵심은 실행자 프레임워크가 작업 수행을 담당해준다는 것이다.
- 자바7 부터 실행자 프레임워크는 포크-조인 태스크를 지원하게 되었다.
  - 포크-조인 태스크는 작은 하위 태스크로 나뉠 수 있고, 포크-조인 풀 이라는 특별한 실행자 서비스의 구성 스레드들이 이들을 처리한다.
  - CPU 를 최대한 활용하며 높은 처리량과 낮은 지연시간을 달성한다.

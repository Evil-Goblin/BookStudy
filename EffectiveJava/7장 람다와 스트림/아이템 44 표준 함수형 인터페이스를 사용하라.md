## 불필요한 함수형 인터페이스를 삼가라.
- 용도에 맞는 표준 함수형 인터페이스가 있다면 그를 사용하는 것이 좋다.
- API 가 다루는 개면의 수가 줄어들어 익히기 더 쉬워진다.
- 표준 함수형 인터페이스들은 유용한 디폴트 메서드를 많이 제공하므로 다른 코드와의 상호운용성이 좋아진다.
  - 함수형 인터페이스의 조합이 가능해진다.

### 대표적인 표준 함수형 인터페이스

| 인터페이스               | 함수 시그니처               | 예                     |
|---------------------|-----------------------|-----------------------|
| `UnaryOperator<T>`  | `T apply(T t)`        | `String::toLowerCase` |
| `BinaryOperator<T>` | `T apply(T t1, T t2)` | `BigInteger::add`     |
| `Predicate<T>`      | `boolean test(T t)`   | `Collection::isEmpty` |
| `Function<T,R>`     | `R apply(T t)`        | `Arrays::asList`      |
| `Supplier<T>`       | `T get()`             | `Instant::now`        |
| `Consumer<T>`       | `void accept(T t)`    | `System.out::println` |

### 주의점
- 표준 함수형 인터페이스 대부분은 기본 타입만 지원한다.
- 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하면 성능에 문제가 생길 수 있다.
- 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의해서는 안 된다.
  - 클라이언트에게 모호함을 안겨주게 된다.
  - `ExecutorService` 의 `submit` 메서드는 `Callable<T>` 와 `Runnable` 을 받는 것이 다중정의 되어있다.
  - 때문에 올바른 메서드를 알려주기 위해 형변환을 해야하는 경우가 생긴다.

## 함수형 인터페이스를 직접 만들어야 하는 경우
- 표준 인터페이스 중 필요한 용도에 맞는게 없는 경우
- 표준 인터페이스와 같더라도 직접 작성해야하는 경우도 있다.
- 대표적으로 `Comparator`
  - API 에서 자주 사용되는데, 지금의 이름이 그 용도를 설명한다.
  - 구현 측에서 반드시 지켜야할 규약을 담고 있다.
  - 비교자들을 변환하고 조합해주는 유용한 디폴트 메서드를 갖고 있다.
- 이상을 만족한다면 전용 함수형 인터페이스를 구현해야할지 고민해야 한다.
  - 자주 쓰이며, 이름 자체가 용도를 명확히 설명한다.
  - 반드시 따라야 하는 규약이 있다.
  - 유용한 디폴트 메서드를 제공할 수 있다.

## @FunctionalInterface
- `@Override` 의 용도와 비슷하다.
- 프로그래머의 의도를 명시한다.
  - 이 인터페이스가 람다용으로 설계된 것임을 알려준다.
  - 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
  - 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아준다.
- **직접 만든 함수형 인터페이스에는 항상 `@FunctionalInterface` 어노테이션을 사용하라.**

## 정리
- 입력값과 반환값에 함수형 인터페이스 타입을 활용하라.
- 보통은 표준 함수형 인터페이스를 사용하는 것이 좋은 선택이다.
- 하지만 직접 새로운 함수형 인터페이스를 만들어 쓰는 편이 나을 때도 있다.

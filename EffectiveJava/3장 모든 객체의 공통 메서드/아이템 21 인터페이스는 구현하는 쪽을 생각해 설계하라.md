## 디폴트 메서드
- 이미 구현된 클래스에 대해서 인터페이스에 메서드를 추가하게 되면 대체로는 컴파일에러가 발생한다.
  - 추가된 메서드까지 구현되어있을 확률이 낮기 때문
- 이를 위해 디폴트 메서드가 생겼지만 디폴트 매서드를 재정의 하지 않은 모든 클래스에서 디폴트 구현이 사용되게 된다.
  - 구현 클래스에 대해 아무것도 모른 채 합의 없이 무작정 '삽입'된다.
- 람다를 활용하기 위해 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었다.
- 하지만 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어렵다.
- 반면, 새로운 인터페이스를 만드는 경우에는 표준적인 메서드 구현에 유용한 수단이다.

## 디폴트 메서드가 추가되며 발생한 문제
- 자바 8의 `Collection` 인터페이스에 추가된 `removeIf` 메서드가 대표적인 예시이다.
  ![removeIf](https://github.com/Evil-Goblin/BookStudy/assets/74400861/8458add0-f43e-4a62-8863-5fe2032c5a20)
- `org.apache.commons.collections4.collection.SynchronizedCollection` 은 락을 사용해 동기화 후 내부 컬렉션 객체에 기능을 위임한다.
- 하지만 특정 버전까지는 `removeIf` 메서드를 재정의 하지 않았기 때문에 동기화없는 동작을 하게 된다.
- 4.4 버전 부터 고쳐졌다.
  ![SynchronizedCollection.removeIf](https://github.com/Evil-Goblin/BookStudy/assets/74400861/04568634-5631-41f7-a323-06304a14c81b)
- `Collections.SynchronizedCollection` 의 경우 이를 방지해두었다.
  ![Collections.SynchronizedCollection.removeIf](https://github.com/Evil-Goblin/BookStudy/assets/74400861/21773e33-c495-4186-9be7-70aa9018769e)
  - `removeIf` 를 재정의하고 호출 전 동기화를 수행한다.
  - 자바 플랫폼의 클래스는 이러한 변화에 대응할 수 있지만 제3의 기존 컬렉션 구현체들은 이러한 언어 차원의 변화에 발맞춰 수정되기 힘들다.

## 디폴트 메서드의 주의점
- 디폴트 메서드는 기존 구현체에 런타임 오류를 일으킬 수 있다.
  - 자바 8은 컬렉션 인터페이스에 많은 디폴트 메서드가 추가되어 기존에 짜여진 많은 코드가 영향받았다고 한다.
- 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야한다.
  - 기존 구현체들과 충돌할 수 있음을 생각해야한다.
- 디폴트 메서드는 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 용도가 아니다.
  - 이런 형태로 인터페이스를 변경하면 기존 클라이언트를 망가뜨리게 된다.

## 정리
- 인터페이스를 설계할 때는 세심한 주의를 기울여야 한다.
- 디폴트 메서드로 기존 인터페이스에 새로운 메서드를 추가하면 위험하다.
- 새로운 인터페이스는 릴리즈 전에 반드시 테스트를 거쳐야 한다.
  - 최소 세 가지는 구현해봐야 한다.
- 인터페이스를 릴리즈한 후 결함을 수정하는 것이 가능한 경우도 있지만, 절대 그 가능성에 기대서는 안된다.

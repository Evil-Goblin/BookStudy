## equals 를 재정의한 클래스 모두에게 hashCode 도 재정의해야 한다.
- 그렇지 않으면 `hashCode` 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 `HashMap` 이나 `HashSet` 같은 컬렉션의 원소로 사용할 때 문제를 일으킨다.
  ![Object.hashCode](https://github.com/Evil-Goblin/springio-guide/assets/74400861/f018d789-d576-4767-ab1d-364cfd33480d)
  > - equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
  > - equals(Object) 가 두 객체를 같다고 판단했다면, 두 객체의 hashCode 는 똑같은 값을 반환해야 한다.
  > - equals(Object) 가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode 가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시 테이블의 성능이 좋아진다.

## 좋은 hashCode 작성 요령
1. `int` 변수 `result` 를 선언한 후 값 `c` 로 초기화한다.
   - `c` 는 해당 객체의 첫번째 핵심 필드를 단계 `2.a` 방식으로 계산한 해시코드이다. (핵심 필드란 `equals` 비교에 사용되는 필드를 말한다.)
2. 해당 객체의 나머지 핵심 필드 `f` 각각에 대해 다음 작업을 수행한다.
   - 해당 필드의 해시코드 `c` 를 계산한다.
     - 기본 타입 필드라면, `Type.hashCode(f)` 를 수행한다. 여기서 `Type` 은 해당 기본 타입의 박싱 클래스다.
     - 참조 타입 필드면서 이 클래스의 `equals` 메서드가 이 필드의 `equals` 를 재귀적으로 호출해 비교한다면, 이 필드의 `hashCode` 를 재귀적으로 호출한다. 계산이 복잡해지는 경우 필드의 표준형을 만들어 그 표준형의 `hashCode` 를 호출한다. 필드의 값이 `null` 이라면 `0` 을 사용한다.
     - 필드가 배열이라면, 핵심 원소 각각을 별도의 필드처럼 다룬다. 이상의 규칙을 재귀적으로 적용해 각 핵심 원소의 해시코드를 계산한 다음, 단계 `2.b` 방식으로 갱신한다. 배열에 핵심 원소가 하나도 없다면 단순히 상수(`0`)를 사용한다. 모든 원소가 핵심 원소라면 `Arrays.hashCode` 를 사용한다.
   - 단계 `2.a` 에서 계산한 해시코드 `c` 로 `result` 를 갱신한다. 코드로는 다음과 같다.
     - `result = 31 * result + c;`
3. `result` 를 반환한다.

### 동치인 인스턴스에 대해서 같은 해시코드를 반환하는지 테스트를 작성하라.

### Objects 클래스의 hash 메서드를 활용할 수 있다.
```java
@Override
public int hashCode() {
    return Objects.hash(lineNum, prefix, areaCode);
}
```
### 불변 클래스이며 해시코드 계산의 비용이 크다면 캐싱을 고려하라.
- 지연초기화(Lazy Loading) 이 좋은 방법이다.

### 성능을 위해 해시코드 계산시 핵심 필드를 생략해서는 안된다.

### hashCode 의 생성 규칙을 API 사용자에게 자세히 공표하지 말아야 한다.
- 클라이언트에서 해당 값에 의지하지 않게 된다.
  - 추후 계산 방식을 바꾸기 수월해진다.

## 정리
- `equals` 재정의 시 `hashCode` 도 반드시 재정의해야 한다.
- `hashCode` 는 `Object` 의 `API` 문서에 기술된 일반 규약을 따라야 하며 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 한다.
- `AutoValue` , `Lombok` 등을 활용하면 훨씬 수월하다.

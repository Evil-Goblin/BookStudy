## 직렬화 형태 선택
- **고민해보고 괜찮다고 판단될 때만 기본 직렬화 형태를 사용하라.**
  - 기본 직렬화 형태는 유연성, 성능, 정확성 측면에서 신중히 고민한 후 합당할 때만 사용해야 한다.
  - 일반적으로 직접 설계하더라도 기본 직렬화 형태와 거의 같은 결과가 나올 경우에만 기본 형태를 사용해야 한다.
- **객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.**
  - 간단한 데이터 클래스의 경우 기본 직렬화 형태를 써도 괜찮을 것이다.
- **기본 직렬화 형태가 적합하다고 결정했더라도 불변식 보장과 보안을 위해 `readObject` 메서드를 제공해야 할 때가 많다.**

### 객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하면 발생하는 문제
- **공개 API 가 현재의 내부 표현 방식에 영구히 묶인다.**
  - 내부의 `private` 클래스조차 공개 API 가 되어버린다.
  - 때문에 다음 릴리즈에도 해당 클래스들을 사용하는 구현도 처리할 수 있어야 한며, 더는 사용하지 않더라도 관련 코드를 절대 제거할 수 없다.
- **너무 많은 공간을 차지할 수 있다.**
  - 내부 구현에 해당하는 내용은 직렬화 형태에 포함할 가치가 없다.
  - 이에 직렬화 형태가 너무 커져서 디스크에 저장하거나 네트워크로 전송하는 속도가 느려진다.
- **시간이 너무 많이 걸릴 수 있다.**
  - 직렬화 로직은 객체 그래프의 위상에 관한 정보가 없으니 그래프를 직접 순회해볼 수밖에 없다.
- **스택 오버플로우를 일으킬 수 있다.**
  - 기본 직렬화 과정은 객체 그래프를 재귀 순회하는데, 이 작업에서 스택 오버플로우가 발생할 위험이 있다.
  - 이는 플랫폼 구현마다, 명령줄 플래그마다 달라지는 문제도 있다.

## transient
```java
private transient int size = 0;
```
- `transient` 한정자는 해당 인스턴스 필드가 기본 직렬화 형태에 포함되지 않는다는 표시이다.
- 기본 직렬화를 사용한다면 `transient` 필드들은 역직렬화될 때 기본값으로 초기화 된다.
- 기본값을 사용해선 안되는 경우 `readObject` 메서드에서 `defaultReadObject` 를 호출한 다음, 해당 필드를 원하는 값으로 복원하거나, 처음 사용할 때 초기화하는 방법도 있다.


## defaultWriteObject
- `defaultWriteObject` 메서드 호출시 `transient` 로 선언하지 않은 모든 인스턴스 필드가 직렬화된다.
- 때문에 `transient` 으로 선언해도 되는 인스턴스 필드에는 모두 `transient` 한정자를 붙여야 한다.
- **해당 객체의 논리적 상태와 무관한 필드라고 확신할 때만 `transient` 한정자를 생략해야 한다.**

## 직렬화시 주의점
- **객체의 전체 상태를 읽는 메서드에 적용해야 하는 동기화 메커니즘을 직렬화에도 적용해야 한다.**
  - 만약 모든 메서드를 `synchronized` 로 선언하여 스레드 안전하게 만든 객체에서 기본 직렬화를 사용하려면 `writeObject` 도 `synchronized` 로 선언해야 한다.
  - `writeObject` 메서드 안에서 동기화하고 싶다면 클래스의 다른 부분에서 사용하는 락 순서를 똑같이 따라야 한다.
  - 그렇지 않으면 자원 순서 교착상태에 빠질 수 있다.
- **어떤 직렬화 형태를 택하든 직렬화 가능 클래스 모두에 직렬 버전 UID 를 명시적으로 부여하자.**
  - 이로인해 직렬 버전 UID 가 일으키는 잠재적인 호환성 문제가 사라진다.
  - 런타임에 이 값을 생성하지 않기 때문에 성능도 조금 빨라지게 된다.
  - `private static final long serialVersionUID = <무작위 long값>;`
  - 직렬 버전 UID 가 꼭 고유할 필요는 없다.
  - 직렬 버전 UID 가 없는 기존 클래스를 구버전으로 직렬화된 인스턴스와 호환성을 유지한 채 수정하고 싶다면, 구버전에서 사용한 자동 생성된 값을 그대로 사용해야 한다.
    - 이 값은 직렬화된 인스턴스가 존재하는 구버전 클래스를 `serialver` 유틸리티에 입력으로 주어 실행하여 얻을 수 있다.
- 기존 버전 클래스와의 호환성을 끊고 싶다면 단순히 직렬 버전 UID 의 값을 바꿔주면 된다.
  - 이로 인해 기존 버전의 직렬화된 인스턴스를 역직렬화할 때 `InvalidClassException` 이 던져질 것이다.
  - **구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID 를 절대 수정하지 말자.**

## 정리
- 클래스를 직렬화하기로 했다면 어떤 직렬화 형태를 사용할지 심사숙고해야 한다.
- 자바의 기본 직렬화 형태는 객체를 직렬화한 결과가 해당 객체의 논리적 표현에 부합할 때만 사용하고, 그렇지 않으면 객체를 적절히 설명하는 커스텀 직렬화 형태를 고안하라.
- 직렬화 형태도 공개 메서드를 설계할 때에 준하는 시간을 들여 설계해야 한다.
- 한번 공개된 메서드는 향후 릴리즈에서 제거할 수 없듯이, 직렬화 형태에 포함된 필드도 마음대로 제거할 수 없다.
  - 직렬화 호환성을 유지하기 위해 영원히 지원해야 하는 것이다.
- 잘못된 직렬화 형태를 선택하면 해당 클래스의 복잡성과 성능에 영구히 부정적인 영향을 남긴다.

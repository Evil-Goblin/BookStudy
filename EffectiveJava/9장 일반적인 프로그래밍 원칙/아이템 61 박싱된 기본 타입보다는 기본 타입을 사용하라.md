## 자바의 데이터 타입
- `int` , `double` , `boolean` 같은 기본타입
- `String` , `List` 같은 참조타입
- 기본 타입에도 대응되는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다.
- `int` -> `Integer` , `double` -> `Double` , `boolean` -> `Boolean`

## 기본 타입과 박싱된 기본 타입의 차이
- 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성이라는 속성을 갖는다.
  - 박싱된 기본 타입의 두 인스턴스는 값이 같아도 다르다고 식별될 수 있다.
- 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 `null` 을 가질 수 있다.
- 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

### 기본 타입과 박싱된 기본 타입의 비교
```java
Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```
- `Integer` 값을 오름차순으로 정렬하는 비교자이다.
- 이는 별 다른 문제가 없어보이고, 실제로 `Collections.sort` 에 사용하더라도 아무 문제가 없다.
- 하지만 `naturalOrder.compare(new Integer(42), new Integer(42))` 이 결과값을 출력해보면 문제가 드러난다.
  - 두 인스턴스의 값은 42로 같기 때문에 0이 리턴되어야 할 것 같지만 실제로는 1을 출력한다.
  - 첫번째 검사인 `(i < j)` 는 `Integer` 인스턴스가 기본 타입 값으로 변환됨으로 정상 동작한다.
  - 하지만 두번째 검사인 `(i == j)` 는 `Integer` 인스턴스의 레퍼런스값을 비교하게 되고 서로 다른 인스턴스이기 때문에 0이 아닌 1이 출력되게 된다.
  - **박싱된 기본 타입에 `==` 연산자를 사용하면 오류가 일어난다.
- 만약 이와 같이 기본 타입을 다루는 비교자가 필요하다면 `Comparator.naturalOrder()` 를 사용하자.
- 만약 비교자를 직접 만들면 비교자 생성 메서드나 기본 타입을 받는 정적 `compare` 메서드를 사용해야 한다.
- 또는 박싱된 `Integer` 매개변수의 값을 기본 타입 정수로 저장한 다음, 기본 타입 정수로 비교를 수행해야 한다.
```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed;
    return i < j ? -1 : (i == j ? 0 : 1);
}
```

### 박싱된 기본 타입의 nullable
```java
public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if (i == 42)
            System.out.println("Unbelievable");
    }
}
```
- 이 코드는 `i == 42` 를 검사할 때 `NullPointerException` 을 던지게 된다.
- 이는 `i` 가 `int` 가 아닌 `Integer` 이며, 다른 참조 타입 필드와 마찬가지로 `i` 의 초깃값도 `null` 이기 때문
- 즉 `i == 42` 는 `Integer` 와 `int` 를 비교하기 때문에 자동으로 언박싱 되며 `NullPointerException` 이 발생한다.
  - **기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.**

```java
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i < Integer.MAX_VALUE; i++) {
        sum += i;
    }
    return sum;
}
```
- 이전에도 소개된 문제로 박싱과 언박싱이 반복해서 일어나 성능이 매우 느려진다.

## 박싱된 기본 타입의 사용처
- 컬렉션의 원소, 키, 값으로 사용한다.
  - 컬렉션은 기본 타입을 담을 수 없으므로 박싱된 기본 타입을 사용해야 한다.
  - 매개변수화 타입, 매개변수화 메서드의 타입 매개변수로는 박싱된 기본타입을 사용해야 한다.
- 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본타입을 사용해야 한다.

## 정리
- 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 기본 타입을 사용하자.
- 기본 타입은 간단하고 빠르다.
- 박싱된 기본 타입을 써야 한다면 주의를 기울이자.
- **오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.**
- 두 박싱된 기본 타입을 `==` 연산자로 비교한다면 레퍼런스를 비교하기 때문에 문제가 될 가능성이 크다.
- 같은 연산에서 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며, **언박싱 과정에서 `NullPointerException` 을 던질 수 있다.**
- 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있다.

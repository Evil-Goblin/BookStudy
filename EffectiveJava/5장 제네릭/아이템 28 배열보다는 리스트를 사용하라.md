## 배열과 제네릭 타입의 차이
1. 배열은 공변이다.
   - `Sub` 가 `Super` 의 하위 타입이면 배열 `Sub[]` 는 배열 `Super[]` 의 하위 타입이 된다.(공변, 함께 변한다.)
   - 반면, 제네릭은 불공변이라서 `List<Type1>` 과 `List<Type2>` 는 하위 타입도 상위 타입도 아니다.
   ```java
   Object[] objectArray = new Long[1];
   objectArray[0] = "타입이 달라서 넣을 수 없다."; // ArrayStoreException
   ```
   - 이 코드는 컴파일단계에서 걸러지지 않고 런타임에 에러가 발생한다.
   
   ```java
   ArrayList<Object> ol = new ArrayList<Long>();
   ol.add("타입이 달라 넣을 수 없다.");
   ```
   - 이 코드는 컴파일단계에서 실패하기 때문에 타입 안전성이 지켜진다.

2. 배열은 실체화된다.
   - 배열은 런타임에도 원소의 타입을 인지하고 확인한다.
     - 위의 코드에서 `Long` 배열에 `String` 을 담으려 시도하여 `ArrayStoreException` 이 발생한다.
   - 제네릭은 타입 정보가 런타임에 소거된다.
     - 컴파일에서만 검사하며 런타임에는 사라진다.

### 배열과 제네릭은 어우러지지 못한다.
- 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다.
  - `new List<E>[]` , `new List<String>[]` , `new E[]` 와 같이 작성하면 컴파일단계에서 제네릭 배열 생성 오류를 발생한다.
- 제네릭 배열을 만들지 못하게 막은 이유는 타입 안전성 때문이다.
  - 컴파일러가 자동 생성한 형변환 코드에서 런타임에 `ClassCastException` 이 발생할 수 있다.
  ```java
  List<String>[] stringList = new List<String>[1];
  List<Integer> intList = List.of(42);
  Object[] objects = stringList;
  objects[0] = intList;
  String s = stringList[0].get(0);
  ```
  - 제네릭 배열 생성을 막은 이유를 보여주는 코드이다.
  - 당연히 컴파일 되지 않는다.
- 제네릭 컬렉션에서는 자신의 원소 타입을 담은 배열을 반환하는게 보통은 불가능하다.
- 제네릭 타입과 가변인수 메서드를 함께 쓰면 해석하기 어려운 경고 메시지를 받게 된다.
  - 가변인수 메서드를 호출할 때마다 가변인수 매개변수를 담을 배열이 만들어진다.
  - 이때 그 배열의 원소가 실체화 불가 타입이라면 경고가 발생한다.
  - `@SafeVarargs` 어노테이션으로 대처할 수 있다.
  ![List.of](https://github.com/Evil-Goblin/BookStudy/assets/74400861/74f87fd8-500b-4b99-8e1f-f296c1a28e1d)
  _List 의 of 가변인수 메서드_

## 배열대신 리스트를 사용하라.
- 배열로 형변환할 때 제네릭 배열 생성오류나 비검사 형변환 경고가 뜨는 경우 `E[]` 대신 `List<E>` 를 사용하면 대부분 해결된다.
- 물론 코드가 조금 복잡해지고 성능이 살짝 나빠질 수 있다.
- 하지만 타입 안전성과 상호운용성이 좋아진다.

## 정리
- 배열과 제네릭에는 다른 타입 규칙이 적용된다.
- 배열은 공변이고 실체화된다.
- 제네릭은 불공변이고 타입 정보가 소거된다.
- 배열은 런타임에는 타입이 안전하지만 컴파일타임에는 그렇지 않다.
- 제네릭은 컴파일타임에는 안전하지만 런타임에는 그렇지 않다.
- 이 둘을 섞어 쓰는 것은 쉽지 않다.
- 만약 둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 배열을 리스트로 대체하는 방법을 적용해보자.

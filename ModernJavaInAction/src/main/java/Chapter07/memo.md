## 병렬 스트림에서 사용하는 스레드 풀 설정
- 병렬 스트림은 내부적으로 `ForkJoinPool` 을 사용한다.
- `ForkJoinPool` 은 프로세서 수(`Runtime.getRuntime().availableProcessors()`)에 상응하는 스레드를 갖는다.
- `System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "12");` 을 통해 설정할 수 있다.
  - 전역 설정 코드이기 때문에 이후의 모든 병렬 스트림 연산에 영향을 준다.
  - 왠만하면 기본값을 그대로 사용하는 것이 좋다.

## 성능 최적화시 세 가지 황금 규칙
1. 측정
2. 측정
3. 측정

### 병렬 스트림 성능 측정과 결과
- iterate 는 제네릭타입이다보니 박싱된 기본타입을 이용하게 되어 오토박싱 언박싱의 반복때문에 성능이 별로 좋지 않다.
- rangeClosed 는 언박싱된 기본타입을 이용하게 되어 성능이 월등히 좋다.
- 또한 iterate 는 연산의 분할이 불가능하기 때문에 parallel 을 이용하면 성능이 오히려 나빠진다.(스레드의 생성 비용)
- 반면 rangeClosed 는 연산의 분할이 가능하기 때문에 성능이 좋다.

## 병렬 스트림시 Thread-safe 확인 중요
- 연산이 상태를 갖고 `Thread-safe` 하지 않다면 병렬 처리시 데이터 레이스가 발생해 정상적인 결과가 도출되지 않는다.

## 병렬 스트림 효과적으로 사용하기
- 순차 스트림과 병렬 스트림은 쉽게 바꿀 수 있기 때문에 어느 것이 나은지 직접 측정하고 선택해야한다.
- 박싱을 주의해야 한다.
  - 자동 박싱과 언박싱은 성능을 크게 저하시킨다.
  - 되도록 기본형 특화 스트림(`IntStream` , `LongStream` , `DoubleStream`) 을 사용한다.
- 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다.
  - `limit` , `findFirst` 와 같이 요소의 순서에 의존하는 연산은 병렬 스트림에 적절하지 않다.
- 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라.
  - 처리해야 할 요소 수가 `N` 이고 하나의 요소를 처리하는 데 드는 비용을 `Q` 라고 할 때 천체 스트림 파이프라인 처리 비용은 `N * Q` 로 예상할 수 있다.
  - 만약 `Q` 가 높아진다면 병렬 스트림으로 성능을 개선할 수 있는 가능성이 있다.
- 소량의 데이터에서는 병렬 스트림이 도움 되지 않는다.
  - 소량의 데이터는 병렬화 과정에서 생기는 부가 비용을 상쇄할 수 있을 만큼 이득을 얻지 못한다.
- 스트림을 구성하는 자료구조가 적절한지 확인하라.
  - `ArrayList` 는 `LinkedList` 보다 효율적으로 분할할 수 있다.
  - `LinkedList` 를 분할하려면 모든 요소를 탐색해야 하지만 `ArrayList` 는 요소를 탐색하지 않고도 리스트를 분할할 수 있다.
  - `range` 팩토리 메서드로 만든 기본형 스트림도 쉽게 분해 가능하다.
  - `Spliterator` 를 구현해서 분해 과정을 완벽하게 제어할 수 있다.
- 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다.
  - `SIZED` 스트림은 정확히 같은 크기의 두 스트림으로 분할할 수 있기 때문에 효과적으로 병렬 처리할 수 있다.
  - 반면, 필터 연산이 있으면 스트림의 길이를 예측할 수 없기 때문에 효과적으로 병렬 처리할 수 있을지 알 수 없다.
- 최종 연산의 병합 과정 비용을 살펴보라.
  - 병합 과정의 비용이 비싸다면 병렬 스트림으로 얻은 성능의 이익이 서브스트림의 부분 결과를 합치는 과정에서 상쇄될 수 있다.

### 스트림 소스와 분해성

| 소스              | 분해성 |
|-----------------|-----|
| ArrayList       | 훌륭함 |
| LinkedList      | 나쁨  |
| IntStream.range | 훌륭함 |
| Stream.iterate  | 나쁨  |
| HashSet         | 좋음  |
| TreeSet         | 좋음  |

## Fork/Join 프레임워크 제대로 사용하는 방법
_ForkJoinSumCalculator 참고_
- `join` 메서드를 태스크에 호출하면 태스크가 생산하는 결과가 준비될 때까지 호출자를 블록시킨다.
  - 두 서브 태스크가 모두 시작된 다음 `join` 을 호출해야 한다.
- `RecursiveTask` 내에서는 `ForkJoinPool` 의 `invoke` 메서드를 사용하지 말아야 한다.
  - 대신 `compute` 나 `fork` 메서드를 직접 호출할 수 있다.
  - 순차 코드에서 병렬 계산을 시작할 때만 `invoke` 를 사용한다.
- 서브태스크에 `fork` 메서드를 호출해서 `ForkJoinPool` 의 일정을 조절할 수 있다.
  - 왼쪽 작업과 오른쪽 작업 모두에 `fork` 를 호출하는 것 보다 한쪽에는 `fork` 다른 한쪽에 `compute` 를 호출하는 것이 효율적이다.
  - 불필요한 태스크를 할당하는 오버헤드를 피할 수 있다.(스레드풀 최적화)
- 포크/조인 프레임워크를 이용하는 병렬 계산은 디버깅하기 어렵다.
  - 각각 스레드를 특정할 수 없기 때문에 스택 트레이스가 도움이 되지 않는다.
- 병렬 스트림과 같이 포크/조인 프레임워크를 이용하는 것이 순차 처리보다 무조건 빠를 것이라는 생각은 버려라.
  - 병렬 처리로 성능이 개선되려면 태스크를 여러 독립적 서브태스크로 분할할 수 있어야 한다.
  - 각 서브태스크의 실행시간은 새로운 태스크를 포킹하는 데 드는 시간보다 길어야 한다.

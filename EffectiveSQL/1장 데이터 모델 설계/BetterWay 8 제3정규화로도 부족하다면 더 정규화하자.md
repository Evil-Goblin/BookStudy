## 정규화
- 흔히 어플리케이션은 제3정규화로 충분하다고 한다.
  - 대부분은 '일반적으로 제3정규화면 충분하다' , '일단 최대한 정규화한 후 어플리케이션이 제대로 돌아갈때까지 역정규화하라' 는 경구만 듣고 재인용한다.
- 대부분의 데이터 모델에서 제3정규화를 거친 엔티티는 더 높은 수준의 정규화를 만족할 가능성이 크다.
  - 실제로 오늘날 많은 데이터베이스에서 이미 5, 6정규화까지 도달했음에도 이를 제3정규화로 칭한다.
- 제3정규화로 설계했지만, 한 테이블이 다른 테이블 두 개 이상과 관계를 맺는다면 더 높은 정규화 형식을 위반할 수 있으므로 주의해야 한다.
  - 다대다 관계가 둘 이상일 때는 더욱 주의해야 한다.
  - 테이블에 더 높은 정규화 형식을 위반할 수 있는 복합키가 있을 때도 마찬가지다.

### 처음 세가지 정규화 형식(`Boyce-Codd` 정규화 포함)은 관계의 속성 중 기능적 의존성이 있는 속성과 관련되었다고 할 수 있다.
  - 기능적 의존성은 해당 속성이 관계를 이루는 키에 의존함을 의미한다.

### 제4정규화 형식은 다치 종속과 관련이 있다.
  - 두 속성이 서로 독립적이지만 관계에서 동일한 키에 의존하는 경우 두 속성 간에 가능한 조합을 만든다.

![판매원이_판매한_제품_정보가_있는_테이블](https://github.com/Evil-Goblin/BookStudy/assets/74400861/26589b52-975c-479c-8b38-e2875a660e43)
_표 1_3_
- 제4정규화 형식을 위반하는 특수한 경우의 예시이다.
- 각 제조사는 두 가지 제품만 생산하고, 판매원은 해당 제조사의 모든 제품을 판매해야 한다.
- 따라서 `Sheila` 가 `Ace` 제품을 팔기로 했다면 로우를 두 개 새로 입력해야 한다.(`Ace` 의 `Dicer` , `Whomper`)
  - 이때 이 테이블의 데이터를 제대로 갱신하지 못하면 데이터 이상이 발생할 수 있다.
  - 이런 오류를 피하기 위해 테이블을 여러 개로 분할해야 한다.

![판매원_재고_데이터베이스의_스키마_다이어그램](https://github.com/Evil-Goblin/BookStudy/assets/74400861/d4ea4715-8da1-4e15-b93e-a0dff2b0a890)
- 이 모델을 사용하면 임의의 판매원이 파ㅏㄴ매할 모든 제품을 나열하기만 하면 된다.
- 이후 `SalesPeopleManufacturers` 와 `ManufacturerProducts` 테이블을 조인해 이전의 설계와 같은 결과를 추출하면 임의의 판매원이 실제로 판매하는 제품을 알아낼 수 있다.
- 하지만 현실적으로 판매원이 어느 한 제조사가 제작한 제품의 일부만 판매할 가능성이 크다.
  - 그렇다면 이전 테이블은 더 이상 제4정규화를 위반하지 않는다.
  - 이것은 더 높은 정규화 형식을 사용할 때가 왜 드문지 그 이유를 분명히 드러낸다.
- 우리가 사용하는 대부분의 비즈니스 규칙 때문에 데이터 모델은 더 높은 정규화 형식을 이미 만족하고 있는 셈이다.

### 제5정규화 형식에서는 후보키가 모든 조인 의존성을 함축해야 한다.
![여러_컬럼에_다중_속성이_포함된_테이블](https://github.com/Evil-Goblin/BookStudy/assets/74400861/c6d2ec0b-1d96-4d81-9c9a-784af5d62ba6)
_표 1-4_
- 이 데이터 모델에서 의사는 특정 장비로 검사할 수 있는 검사실을 예약해야 한다.

![의사,장비,검사실_예약_데이터베이스의_스키마_다이어그램](https://github.com/Evil-Goblin/BookStudy/assets/74400861/8b35e6df-6a5b-46e4-851c-96c0fde80669)
- 주요 테이블 `Doctors` , `Equipment` , `Offices` 와 이들을 쌍으로 연결한 연결 테이블을 만들어 설계할 수 있을 것이다.
  - 이에 새 검사실이 생기거나 기존 검사실에 새 장비가 들어오거나 의사가 받는 교육 내용이 바뀌더라도 이 요소는 모두 독립적이면 각 쌍 간에 이상은 발생하지 않는다.
- 하지만 `DoctorSchedule` 테이블은 이상이 발생할 위험이 있다.
  - 의사가 해당 장비 사용에 필요한 교육을 받지 못했거나 검사실에 장비가 부족하다면 의사와 검사실을 한 쌍으로 하는 테이블을 만들 수는 있지만, 제5정규화를 위반한다.

![의사,장비,검사실_예약_데이터베이스의_개선된_스키마_다이어그램](https://github.com/Evil-Goblin/BookStudy/assets/74400861/91532e7c-965a-4fab-9074-f9d8c8191571)
- 이와 같이 개선할 수 있다.
- `DoctorSchedule` 테이블의 `EquipmentID` 컬럼과 부분적으로 겹치는 외래키가 두 개 있다.
- 이 두 외래키 제약 조건은 어느 특정 장비에서는 유효한 의사와 검사실 조합만 선택할 수 있도록 보장해 프로그래밍 로직윽 작성하지 않아도 되므로 데이터 이상을 방지한다.
  - 관계만 변경했을 뿐 테이블 설계는 변경되지 않았다.
- `DoctorSchedule` 테이블에 `EquipmentID` 컬럼이 필요하지 않았다면 진즉 제5정규화가 되었을 것이다.
  - 따라서 예약 과정의 일부로 의사가 장비에 배정되었는지 확인하지 않고 의사를 검사실에 예약하기만 해도 된다면, 첫 번째 스키마로도 충분할 것이다.
- 예제에서는 복합키를 사용했다.
  - `OfficeEquipment` 와 `DoctorEquipment` 에서 대리키를 생성했다면 `EquipmentID` 컬럼이 모호해졌을 것이기 때문에 개선된 모델에는 반영할 수 없다.
  - 기본값으로 대리키를 사용한다면 해당 키가 스키마에 있는 핵심 정보를 잠재적으로 숨기는지 반드시 조사해야 한다.
  - 다대다 관계에 참여하는 모든 외래키에 주목하고 분석해서 이들이 해당 관계에 어떤 영향을 주는지 확인해야 한다.
- 더 높은 저어규화 형식을 위반하는지 분석할 때 사용할 수 있는 방법 중 하나는 바로 무손실 분할이다.
  - 테이블에 컬럼이 많으면 일련의 부분 집합으로 분할해야 한다.
  - 이들 부분집합에 대해 `SELECT DISTINCT` 문을 수행한 후 `LEFT OUTER JOIN` 을 사용해 다시 조인한 결과가 원래 테이블 결과와 동일한지 확인한다.
  - 분할한 테이블을 재결합한 결과, 데이터 손실이 없다면 원본 테이블은 일부 정규화 형식을 위반한 것이기 때문에 더 면밀히 조사해서 데이터 이상 문제를 일으키는지 파악해야 한다.

![다중_속성이_포함된_테이블_분할](https://github.com/Evil-Goblin/BookStudy/assets/74400861/3f4aff7d-e2cf-4c00-9212-9690d8f25adf)
_표 1-5_
- 표 1-3 테이블을 분할한 테이블이다.

#### 정규화 위반 예
- 이전 제4정규화, 제5정규화 위반 예시의 경우
- 표 1-3 에서 로우 하나를 꺼내면 `SalespeopleManufacturers` 와 `ManufacturerProducts` 테이블을 조인했을 때 데이터 손실이 발생한다.
- 표 1-5 테이블들을 조인한 결과 수정된 표 1-3 의 테이블 데이터가 일치하지 않기 때문이다.
  - 수정된 표 1-3 의 테이블은 더 이상 제4정규화를 위반하지 않는다.
- 마찬가지로 `EquipmentID` 가 `DoctorSchedule` 테이블의 컬럼이 아니라면 다시 데이터 손실이 발생하므로 제5정규화를 위반하지 않는다.

## 정리
- 대부분의 데이터 모델에는 이미 더 높은 정규화가 적용되어 있을 가능성이 높다.
  - 따라서 더 높은 정규화 형식을 명확히 위반하는지 면밀히 관찰해야 한다.
  - 특히 복합키를 사용하거나 여러 다대다 관계에 참여하는 테이블일 때는 더욱 그렇다.
- 한 엔티티에서 관계가 없는 두 속성으로 가능한 모든 조합을 해당 엔티티에 열거해야 하는 특수한 경우에는 제4정규화를 위반할 수 있다.
- 제5정규화는 후보키가 모든 조인 의존성을 함축하는지 확인하는 것이다.
  - 즉, 개별 요소에 근거해 후보키에 유효한 값이 무엇인지 제약할 수 있어야 한다는 말이다.
  - 이것은 키가 복합키일 때만 발생한다.
- 제6정규화는 일반적으로 관계를 키가 아닌 속성 하나로만 줄이는 것이다.
  - 따라서 테이블 개수가 급격히 늘어나지만 널 허용 컬럼을 정의할 필요가 없다.
- 무손실 분할 테스트는 해당 테이블이 더 논ㅍ은 정규화 형식을 위반하는지 감지하는 효과적인 도구가 될 수 있다.

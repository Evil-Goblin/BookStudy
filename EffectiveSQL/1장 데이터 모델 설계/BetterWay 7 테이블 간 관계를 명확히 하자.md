## 테이블 간 관계를 명확히 하자.
- 이론적으로 관련 컬럼의 데이터 타입이 같으면 테이블 간의 어떤 관계든 맺을 수 있다.

![판매주문정보데이터베이스의스키마다이어그램](https://github.com/Evil-Goblin/BookStudy/assets/74400861/2a2721aa-89d6-4ac6-8c58-cac0071ca7cf)
- 잘보면 `Customers` , `Employees` , `Vendors` 의 테이블이 유사함을 알 수 있다.
- 일반적으로는 각 테이블의 데이터 자체는 유일하기 때문에 비슷한 컬럼이 있다고해서 문제가 되지 않는다.
- 하지만 중복되는 정보가 있는 경우 개선이 필요할 수 있다.
  - `Customer` 의 일부가 `Vendor` 이거나 `Employee` 인 경우
- 만약 `Contacts` 테이블로 통합하여 관리하는 방법을 선택하는 경우 기본키 값에 해당하는 `EmployeeID` , `CustomerID` , `VendorID` 가 `ContactID` 로 통합되게 될 것이다.
  - 이 경우 `ContactID` 가 어떤 `ID` 를 가리키는지 구분하기 어렵다.
- `Contacts` 테이블과 일대일 관계를 맺은 `Customers` , `Vendors` , `Employees` 테이블을 만들 수도 있을 것이다.
  - `ManagerID` 나 `VendWebPage` 와 같이 엔티티에 특화된 데이터를 다른 고객 로우와 분리하여 유지하기 쉬워진다.
  - 하지만 데이터베이스 스키마를 사용하는 어플리케이션은 어떤 엔티티이고, 필요한 도메인 특화 데이터는 담았는지를 확인해야할 필요가 생기기 때문에 훨씬 복잡해진다.
  - 만약 어플리케이션이 신규로 입력되는 데이터가 중복 데이터인지 확인하지 않은 채 입력을 허용한다면 추가 테이블은 아무 쓸모가 없어진다.
- 대체로는 공급처나 회사 임직원이 제품을 판매하는 회사의 고객이 될 리는 없기 때문에 이렇게 드물게 발생하는 중복 데이터를 직접 해결하는 것이 데이터베이스 스키마의 간소화에 비해 값싼 편이다.

### 직원에게 판매 지역을 할당하는 시나리오
- 판매 지역을 기준으로 고객과 직원을 연결할 수 있다.
- `Customers` 테이블의 `CustZipCode` 컬럼과 `Employees` 테이블의 `EmpZipCode` 컬럼 간에 관계를 만들 수 있다.
- 이 둘은 같은 도메인에 있고 데이터 타입도 동일하기 때문에 테이블간 관계를 생성하는 대신 `ZIP` 코드 컬럼으로 조인하여 어느 고객이 어느 직원 근처에 사는지 찾을 수 있다.
- `Customers` 테이블에 `EmployeeID` 외래키를 생성해 고객과 직원을 연결하는 것도 가능하지만 고객이 이사를 하는 등의 예외사항에 대처하기 어렵다.
- `SalesTerritory` 테이블을 새로 만들어 `EmployeeID` 를 외래키로 가지도록 하여 직원에게 할당된 `ZIP` 코드를 식별하도록 하는 것이 더 낫다.
  - 하나의 `ZIP` 코드는 하나의 직원에게만 할당할테니 `ZIP` 코드는 `SalesTerritory` 테이블 내에서 유일하다.

### 판매 지역이 아닌 다른 기준에 따라 고객을 직원에게 할당하는 경우
- `Customers` 테이블에 `EmployeeID` 외래키를 생성하는 방법이 고객과 직원간 연결에 실질적인 유동성을 반영하는데 더 좋다.

### 모든 제품을 나열하면서 각 제품의 세부 데이터와 모든 속성을 추출하는 경우
- 만약 회사가 다양한 제품을 판매하는 소매점인 경우 가끔 사용하는 컬럼 몇개를 추가하는 것은 좋은 선택이 아니다.
  - 그렇다고 제품 카테고리별로 테이블을 만들어 각 카테고리에 해당하는 데이터를 모두 저장하지도 않을 것이다.
- 이러한 경우 `XML` , `JSON` 문서를 저장할 수 있는 `Attribute` 컬럼을 생성하는 것이 더 나을 수도 있다.
  - 관계형 테이블에 있는 제품의 속성을 노출하도록 규정하는 비즈니스 규칙이 없을 때는 문제가 되지 않는다.
  - 하지만 임의의 속성을 질의할 수 있어야 할 때는 `ProductAttributes` 테이블에 생성해서 컬럼을 로우로 변환한 후 `Products` 테이블에 있는 제품과 연결해야 목표를 달성할 수 있을 것이다.

```sql
CREATE TABLE Products
(
  ProductNumber   int          NOT NULL PRIMARY KEY,
  ProdDescription varchar(255) NOT NULL
);

CREATE TABLE ProductAttributes
(
  ProductNumber  int          NOT NULL,
  AttributeName  varchar(255) NOT NULL,
  AttributeValue varchar(255) NOT NULL,
  CONSTRAINT PK_ProductAttributes PRIMARY KEY (ProductNumber, AttributeName)
);

ALTER TABLE ProductAttributes
  ADD CONSTRAINT FK_ProductAttributes_ProductNumber
    FOREIGN KEY (ProductNumber)
      REFERENCES Products (ProductNumber);
```
- 속성 값을 컬럼이 아닌 로우로 저장함으로서 문제가 해결된 것 같지만 특정 속성의 특정 제품을 추출하는 쿼리는 훨씬 복잡해졌다.

## 속성 문제를 위해 정형 데이터와 반정형 데이터를 구별할 수 있는 능력이 필요하다.
- 관계형 모델에서는 실제 데이터를 입력하기 전에 가능한 모든 컬럼과 데이터 타입을 나열해 데이터를 제대로 정의해야 한다.
  - 이는 `XML` , `JSON` 과 같이 레코드 수준에서 동일한 스키마를 가질 필요가 없는 반정형 데이터와는 정반대이다.
  - 때문에 관계정의가 어렵다면 혹시 반정형 데이터를 다루고 있는지는 않은지, 관계형 모델에서 직접 반정형 데이터를 사용할 필요는 없는지 확인해보는 것이 좋다.
  - 현재의 `SQL` 은 `XML` , `JSON` 을 직접 사용할 수 있다.

## 정리
- 컬럼이 비슷한 테이블을 서로 병합해 관계를 간소화하는 것이 정말 타당한지 면밀히 검토한다.
- 데이터 타입이 일치한다면(또는 묵시적 타입 변환이 가능하다면) 두 테이블에 있는 컬럼간 조인을 생성할 수 있다.
  - 이 관계는 해당 컬럼이 같은 도메인에 있을 때만 성립한다.
  - 하지만 조인에 사용되는 두 컬럼의 데이터타입은 동일한 것이 가장 좋다.
- 데이터 모델에서 실제로 정형 데이터를 다루고 있는지 확인한다.
  - 다루는 데이터가 반정형이라면 필요한 대응책을 마련한다.
- 일반적으로 데이터 모델의 목표를 명확히 식별하면, 주어진 설계의 간소화 데이터 모델을 사용하는 어플리케이션의 설계에 기인한 복잡성이나 이상 동작을 정당화하는지 판단하는데 도움이 된다.

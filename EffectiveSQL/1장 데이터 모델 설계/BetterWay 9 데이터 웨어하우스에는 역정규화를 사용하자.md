## 정규화의 장점
- 정규화된 테이블은 비정규화된 테이블에 비해 컬럼의 개수가 적고 저장공간도 많이 차지하지 않는다.
- 데이터가 여러 테이블에 분산되어 테이블이 버퍼에 들어갈 만큼 작기 때문에 성능이 좋아진다.
- 데이터가 단일 공간에 있으므로 갱신과 삽입도 빠르게 수행된다.
- 중복된 데이터가 없으니 `GROUP BY` 절이나 `DISTINCT` 쿼리 사용이 줄어든다.

## 정규화의 단점
- 어플리케이션은 쓰기 작업이 많아서 읽기보다는 쓰기에 부하가 더 걸린다.
- 정규화된 테이블에서 정규화된 데이터는 테이블 간 조인을 의미한다.
- 조인이 많을수록 옵티마이저가 최적의 실행 계획을 찾기 어려워 읽기 성능이 떨어질 수 있다.

## 역정규화의 장점
- 역정규화된 데이터베이스는 읽기 작업이 많을 때도 잘 작동한다.
- 데이터가 소수의 테이블에 있기 때문에 필요한 조인 횟수가 적거나 아예 없어서 `SELECT` 속도가 빠르다.
- 필요한 데이터를 담은 단일 테이블을 사용하면 인덱스를 훨씬 효율적으로 사용할 수 있다.
  - 데이터 쓰기 작업이 빈번하지 않는다면 인덱스가 쓰기 성능에 심각한 영향을 줄까 걱정하지 않아도 된다.
  - 필요한 경우 테이블의 모든 컬럼에 인덱스를 만들어 조회와 정렬 성능을 크게 높일 수 있다.

## 역정규화 방법
- 테이블에 있는 `IDENTITY` 필드를 복제해 조인을 없앤다.
  - 정규화된 데이터베이스에서 고객을 회계관리자와 연결하고 `Customers` 테이블에 `EmployeeID` 컬럼을 외래키로 만든 경우
    - 회계 관리자 데이터를 포함해 청구서 정보를 조회한다면 테이블을 세 개(`Invoices`, `Customers`, `Employees`) 조인해야 한다.
    - 하지만 `Invoices` 테이블에 `EmployeeID` 컬럼을 두면 `Invoices` 와 `Employees` 테이블만 조인한다.
  - 만약 고객 이름으로 청구서 정보를 많이 검색한다는 사실을 알았다면, `Invoices` 테이블에 `CustomerID` 뿐만 아니라 고객 이름도 저장하고 인덱스까지 만들어 놓으면 좋을 것이다.
- 다른 테이블을 가리키는 필드를 추가한다.
  - 성능이 향상되고 이력 정보를 관리하는 데도 도움이 된다.
  - 고객의 현재 주소는 `Customers` 테이블에 저장되어있고, 고객이 이사하면 이전 주소가 새 주소로 바뀐다.
  - 만약 고객의 주소 이력 정보를 관리하지 않는다면 이전 청구서의 정확한 사본을 출력할 수 없게 된다.
- 계산된 값이나 파생 값을 저장한다.
  - `InvoiceDetails` 테이블의 각 로우에 있는 청구서 금액을 더하는 대신 `Invoices` 테이블에 총 청구서 금액 정보를 저장한다면, 조회 대상 테이블의 개수도 줄어들고 반복적인 계산도 없앨 수 있다.
  - 계산된 값을 저장하면 임의의 계산을 수행하는 방법이 여러 개일 때 이점이 있다.
  - 값을 테이블에 저장해 놓으면 해당 데이터베이스에 대한 쿼리는 계산 결과가 모두 동일하다.
- 반복 그룹을 사용한다.
  - 월간 성능을 비교하는 일이 많다면 단일 로우에 12개월 정보를 저장해 조회 대상 로우의 개수를 줄일 수 있다.

## 데이터 웨어하우스
- 데이터 웨어하우스 시스템에서 데이터 분할 및 분석 방법에 대한 요구 사항은 다양하다.

### 팩트 테이블
- 기업의 기본적인 측정치 데이터
- 대부분의 데이터 웨어하우스 쿼리의 궁극적 대상

#### 팩트 테이블 유형
- 트랜잭션 팩트 테이블
  - 단일 시점에 측정된 데이터를 담은 테이블
- 주기적 스냅샷 팩트 테이블
  - 재무 보고 기간처럼 미리 정의된 시간 동안 또는 그 마지막 시점의 데이터를 요약한 테이블
- 누적 스냅샷 팩트 테이블
  - 주문 처리, 클레임 처리, 서비스 콜 처리, 대학 입학 등 시작과 끝 시점이 잘 정의된 예측 가능한 프로세스 데이터를 담은 테이블

## 정리
- 중복으로 저장할 데이터와 그 이유를 정한다.
- 데이터를 일치된 상태로 유지할 계획을 세운다.
- 역정규화된 필드를 사용하도록 쿼리를 리팩토링한다.

## 주의
- 해당 책은 특정 DBMS 가 아닌 SQL 을 다루고 실행 계획은 DBMS 의 물리적인 구현 내용에 의존적이므로 매우 특화된 내용은 다루기 어렵다.
  - DBMS 의 구현방식은 저마다 다르다.
  - 동일한 개념에서도 다른 용어를 사용한다.
- 하지만 SQL 데이터베이스를 사용하는 사람이라면 쿼리 최적화, 인덱스나 모델 설계에서 필요한 스키마 변경을 수행할 수 있도록 실행 계획을 읽는 방법과 실행 계획의 의미를 이해해야 한다.

## SQL 의 목표
- 데이터를 효율적인 방식으로 가져오려고 물리적인 단계를 기술하는 단조로운 작업에서 개발자를 해방시키는 것
- 얻으려는 데이터를 선언적으로 기술하고, 데이터를 가져오는 최상의 방법을 찾는 일은 옵티마이저에게 일임한다.

## 인덱스 시스템은 쿼리의 종류에 매우 크게 의존한다.
- 도서관에서 책을 찾는다고 가정한다.
- 만약 책 제목으로 정렬되어있다고 가정한다면 책 제목을 기준으로 검색하기 용이하다.
- 하지만 저자로 검색을 하고 싶다면 도서관의 모든 책을 찾아야 한다.
- 저자를 기준으로 책을 모아두어도 해당 저자가 저술한 모든 책의 페이지를 알기 위해선 다시 모든 내용을 조회해야한다.
- 이렇듯 인덱스 시스템은 쿼리의 종류에 매우 크게 의존한다.
  - 때로는 인덱스만으로 조회가 완료되는 경우도 있고 이것이 원하는 데이터를 가장 빠르게 찾는 방법이다.

## 실행 계획
```sql
SELECT CustCity
FROM Customers
WHERE CustAreaCode = 530;
```
- 지역 코드를 기준으로 고객을 조회하는 쿼리이다.

![Key_Lookup_연산이_있는_초기_실행_계획](https://github.com/Evil-Goblin/BookStudy/assets/74400861/9fe3755f-0576-42d0-8cf0-9fa752b4d6dc)
- 만약 제법 큰 테이블이라면 이와 같은 실행 계획이 나올 것이다.
- 물리적인 동작은 다음과 같을 것이다.
  - CustAreaCode 가 포함된 카드 목록으로 가서 색인 카드에서 위치 코드를 찾는다.
  - 찾아낸 각 색인 카드에 표시된 책장으로 가서 CustCity 값을 읽으려고 레코드를 찾는다.
  - 다음 색인 카드를 읽으려고 카드 목록으로 돌아간다.
    - 이 내용이 Key Lookup 연산의 동작 방식이다.
- Index Seek 연산은 카드 목록을 훑어보는 것을 의미한다.
- Key Lookup 연산은 색인 카드에 포함되지 않은 추가 정보를 얻으려고 책장으로 가는 것을 의미한다.
- 만약 레코드가 적은 테이블에서는 나쁘지 않은 실행 계획이다.
  - 하지만 찾아낸 색인 카드가 많고 책장과 카드 목록 사이를 자주 왔다 갔다 한다면 많은 시간이 소요된다.
- 이를 해결하기 위한 해결책으로 인덱스를 추가할 수 있다.
  - 만약 자주 수행되는 쿼리라면 CustCity 를 인덱스에 추가하는 선택이 현명하다.

```sql
CREATE INDEX IX_Customers_CustArea
ON Customers (CustAreaCode, CustCity);
```
- 개선한 인덱스 정의이다.

![인덱스_적용](https://github.com/Evil-Goblin/BookStudy/assets/74400861/47920018-c841-4dbf-9cfa-3c70af2fc9b2)
- 인덱스를 적용한 후 실행 계획이다.
- Key Lookup 없이 Index Seek 만으로 해결이 되어 훨씬 효율적이다.

```sql
SELECT p.*
FROM Products AS p
WHERE NOT EXISTS (
    SELECT NULL
    FROM Order_Details AS d
    WHERE p.ProductNumber = d.ProductNumber
);
```
- 주문을 전혀 하지 않은 고객을 찾는 쿼리이다.
- EXISTS 와 연관성 있는 서브쿼리를 사용한 예시로 사용한다.

![서브쿼리_실행_계획](https://github.com/Evil-Goblin/BookStudy/assets/74400861/899fd78e-9aff-4bfc-962d-c2db9426af0c)
- 위 쿼리의 실행 계획이다.
- 동작은 다음과 같을 것이다.
  - Products 테이블에 대한 'Clustered Index Scan' 은 제품 상세 내역이 있는 한 카드 목록에서 먼저 색인 카드 한 덩어리를 뽑아내는 동작이다.
  - Order_Details 에 대한 'Index Scan' 은 주문 정보가 있는 카드 목록에서 색인 카드 한 덩어리를 뽑아내는 것이다.
  - 'Stream Aggregate' 는 동일한 ProductNumber 가 포함된 모든 색인 카드를 그룹으로 묶는 것이다.
  - 'Merge Join' 은 뽑아낸 두 덩어리의 색인 카드를 정렬한 후 Order_Details 덩어리에서 가져온 카드와 일치하지 않는 제품 색인 카드를 뽑는 것이다.
    - Merge Join 은 'left anti-semi-join' 이다.
    - 개념적으로 세미 조인은 일치하는 모든 로우가 아닌 오직 한 번만 일치하는 로우를 선택하는 조인이다.
    - 안티세미조인은 다른 쪽 집합과 일치하지 않는 고유한 로우를 선택한다.
  - 이를 통해 원하는 정보가 추출된다.
- 원래의 쿼리는 서브쿼리가 포함되었기 때문에 서브쿼리를 수행할 것을 예상할 수 있지만 실제론 그렇지 않았다.
  - 데이터베이스 엔진이 더 효율적인 실행 계획을 세워냈다.
- 하지만 실행 계획은 일련의 물리적 동작이기에 동일한 쿼리에도 데이터ㅑ 크기와 분표가 변하면 극적으로 달라진다.

![또_다른_실행_계획](https://github.com/Evil-Goblin/BookStudy/assets/74400861/1a2535eb-22c6-4483-b002-a6848a3d4a17)
- 같은 쿼리를 더 작은 데이터 집합에 대해 수행한 실행 계획이다.
- Order_Details 테이블에 대한 'Index Seek' 이 Products 테이블의 'Clustered Index Scan' 에서 값 하나를 가져오는 조건 부분이 명확히 표현되어 있지 않다.
- 'Top' 연산은 오직 한 로우만 가져와 Products 테이블의 레코드와 일치하는 건을 추출하도록 결과를 제한한다.
- 이는 'Key Lookup' 과 비슷하다.
- 데이터 집합이 충분히 작기 때문에 데이터 한 덩어리를 가져오는 대신 'Key Lookup' 과 같은 연산을 수행하는 것이 좋다고 데이터베이스 엔진이 결정한 것이다.
  - 이 방법이 작업량이 적다.

## 코끼리와 쥐 문제
- 데이터베이스 엔진의 물리적인 동작은 데이터 분포에 의존한다.
- 따라서 매개변수화된 쿼리는 특정 값에서는 월등한 성능으로 수행되지만 다른 값에서는 현격히 느리게 수행될 수 있다.
- 데이터베이스 엔진은 매개변수화된 쿼리(저장 프로시저)에 대응하는 실행 계획을 저장해 놓는다.

```sql
SELECT o.OrderNumber, o.CustomerID
FROM Orders AS o
WHERE EmployeeID = ?;
```
- 만약 `EmployeeID = 751` 이라는 조건을 수행하고, 이 값은 전체 로우 160,944 중 99 로우만큼 조회된다고 가정한다.

![인덱스에서_소수의_레코드를_읽는_실행_계획](https://github.com/Evil-Goblin/BookStudy/assets/74400861/553d2f53-9e2e-44be-9b24-b9bd5e2428c8)
- 전체 로우에 비해 상대적으로 적은 로우가 리턴되기 때문에 위와 같은 실행 계획이 생성된다.

![다수의_레코드를_읽는_실행_계획](https://github.com/Evil-Goblin/BookStudy/assets/74400861/00121b54-d531-4ca7-8199-211b8156e48a)
- 만약 `EmployeeID = 708` 이라는 조건이 전체 중 5414 로우를 반환한다고 가정한다면 위와 같은 실행 계획이 생성될 것이다.
- 많은 레코드가 흩어져 있기 때문에 모든 데이터를 대상으로 검색하는 것이 빠르다고 결정된 결과이다.
- 이는 인덱스를 추가해 성능을 향상시킬 수 있다.

```sql
CREATE INDEX IX_Orders_EmployeeID_Included
ON Orders (EmployeeID)
INCLUDE (OrderNumber, CustomerID);
```
- 이 인덱스는 EmployeeID 가 751 인 경우도, 708 인 경우도 적용이 가능해진다.
  - 코끼리와 쥐 모두의 실행 계획을 개선한다.

![향상된_실행_계획](https://github.com/Evil-Goblin/BookStudy/assets/74400861/454accb2-6e48-4389-8d60-ac765ebe8293)
- 인덱스를 추가하여 실행 계획이 개선되었다.
- 하지만 이 방법은 모든 상황에서 사용할 수는 없다.
- 복잡한 쿼리일 때 오직 한 쿼리에만 적용되는 유용한 인덱스를 생성한다고 성능이 좋아지지는 않는다.
- 때문에 여러 쿼리에 적용되는 유용한 인덱스를 만들기 위해 기존 인덱스에 컬럼을 추가하고 제거하기도 한다.
- 이런 경우 매개변수화된 쿼리에서도 여전히 '코끼리와 쥐' 문제를 일으킬 수 있어 쿼리를 다시 컴파일하기도 한다.
  - 보통 쿼리 컴파일 시간이 전체 수행 시간에 포함되기 때문
- 가능하면 데이터베이스 제품에서 다시 컴파일하도록 강제하는 옵션의 여부를 조사해야 한다.
- Oracle 같은 데이터베이스 엔진은 캐시에 저장된 실행 계획을 실행하기에 앞서 매개변수를 미리 엿보는 기능을 지원한다.

## 정리
- 실행 계획을 읽을 때마다 실행 계획을 물리적 동작으로 해석하며, 사용되지 않는 인덱스가 있는지 분석해 그 이유를 파악한다.
- 실행 계획의 개별 단계를 분석하고 효율적인지 판단한다.
  - 효율성은 데이터 분포의 영향을 받는다.
  - 결론적으로 '나쁜'연산은 없다.
  - 다만 쿼리에 적합한 연산이 무엇인지 분석한다.
- 좋은 실행 계획을 얻으려면 한 쿼리에 국한되지 않는 인덱스를 추가한다.
  - 데이터베이스의 전반적인 가용성을 고려해 추가한 인덱스가 가능한 한 많은 쿼리에 적용되는지 확인한다.
- 데이터 분포가 동등하지 않고 동일한 쿼리에서도 다른 최적화 기법이 필요한 '코끼리와 쥐' 상황에 유의한다.
  - 이런 상황은 특히 실행 계획을 저장해 두고 재사용할 때(보통 저장 프로시저나 클라이언트 측에 고정된 문장의 경우) 문제가 된다.

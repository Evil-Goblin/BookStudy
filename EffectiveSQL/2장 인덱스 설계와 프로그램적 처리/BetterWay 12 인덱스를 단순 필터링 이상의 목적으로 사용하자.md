## 인덱스
- 인덱스는 데이터베이스 내에 있는 독특한 데이터 구조체이다.
- 생성된 각 인덱스에는 별도의 저장공간이 필요하다.
  - 인덱스화된 테이블 데이터의 복사본이 있어 과잉 데이터를 저장한다.
- 인덱스는 모든 로우를 검색하지 않고 데이터의 위치를 빠르게 찾을 수 있기 때문에 조회 성능이 향상된다.

### 쿼리 수행 알고리즘
- 중첩 루프 조인
  - 쿼리 두개가 중첩되어있는 경우
  - 선행(Outer) 쿼리가 한 테이블에서 결과 집합을 가져오고, 두 번째 쿼리는 선행 쿼리 결과 집합의 각 로우에 대응하는 데이터를 다른 테이블에서 가져온다.
  - 중첩 루프 조인은 조인 조건에 참여하는 컬럼을 인덱스로 만들었을 때 가장 효과가 좋다.
- 해시 조인
  - 조인에 참여하는 한쪽 테이블 데이터를 해시 테이블로 만든 후 다른 쪽 테이블의 각 로우를 매우 빠르게 탐색할 수 있다.
  - 해시 조인을 튜닝할 때는 중첩 루프 조인과는 완전히 다른 인덱스 접근 방법이 필요하다.
  - **해시 테이블을 사용하기 때문에 조인되는 컬럼을 인덱스로 만들 필요가 없다.**
  - **해시 조인의 성능을 향상할 수 있는 유일 인덱스는 `WHERE` 조건절 또는 조인할 때 `ON` 절에 사용되는 컬럼에 대한 인덱스이다.**
  - 현실적으로는 수평적(좀 더 적은 로우) 또는 수직적(좀 더 적은 컬럼) 으로 해시 테이블의 크기를 줄여 성능을 향상시킬 수 있다.
- 소트머지(Sort-merge) 조인
  - 조인 조건에 따라 두 테이블을 각각 정렬한 후 지퍼처럼 정렬된 두 항목을 결합하는 방식
  - 조인 조건 컬럼만 인덱스로 만드는 것은 소용없다.
  - 한 번에 모든 후보 레코드를 읽을 수 있는 독립적인 조건을 구성하는 컬럼에 대한 인덱스가 필요하다.
  - **조인 순서가 별 의미가 없고 성능에도 영향을 미치지 않는다.**
    - 다른 조인 알고리즘은 외부 조인의 방향이 조인 순서를 결정하지만 소트머지 조인은 그렇지 않다.
  - 데이터가 정렬되면 소트머지 조인은 좋은 성능을 발휘하지만, 양쪽 데이터를 정렬하는 비용이 크기 때문에 잘 사용하지 않는다.
    - 정렬 순서대로 만든 인덱스가 있다면 전체 데이터의 정렬을 피할 수 있기 때문에 성능이 향상된다.
    - 해시 조인은 한쪽만 미리 처리하면 되기 때문에 많을 때는 해시 조인이 낫다.

> MySQL 은 해시 조인과 소트머지 조인을 지원하지 않는다.

### 데이터 클러스터링
- 데이터 클러스터링은 연속적으로 접근되는 데이터를 실제로도 인접해서 저장하므로 I/O 연산이 줄어드는 것을 의미한다.

```sql
SELECT EmployeeID, EmpFirstName, EmpLastName
FROM Employees
WHERE EmpState = 'WA' AND EmpCity LIKE '%ELLE%';
``` 
- `LIKE` 표현식은 인덱스를 사용하지 못하지만 `EmpState` 컬럼에 대한 조건은 인덱스로 만들기 적합하다.
- 읽어야 하는 로우가 단일 테이블 블록에 저장되어 있다면 읽기 연산 한 번에 모든 로우를 가져올 수 있다.
  - 하지만 동일한 로우가 다른 블록에 분산해서 저장되어 있을 때, 해당 로우를 모두 가져오려면 많은 블록을 읽어야 함으로 심각한 문제가 될 수 있다.
  - **로우의 물리적인 분포에 따라 성능이 달라진다.**
- 테이블의 로우를 인덱스 순서에 맞게 재정렬해서 쿼리 성능을 향상시킬 수 있지만, 이렇게 처리할 수 있는 경우는 드물다.
  - 물리적인 테이블 로우는 단 하나의 순서로만 저장할 수 있어 오직 한 인덱스에서만 테이블을 최적화할 수 있기 때문이다.
    - 인덱스가 여러개인 경우 하나의 인덱스 종류로만 데이터 클러스터링 효과를 볼 수 있다.

### ORDER BY
- 인덱스는 `ORDER BY` 절의 효율에도 영향을 미친다.
- 정렬은 많은 자원이 필요하다.
  - 보통은 CPU 자원을 많이 사용하지만, 진짜 문제는 임시로 결과를 버퍼에 담아 둔다는 점이다.
    - 즉, 첫 번째 결과가 반환되기 전에 모든 데이터를 읽어야 한다.
- 인덱스에는 인덱스 컬럼 데이터가 정렬되어 있기 때문에 인덱스 사용시 `ORDER BY` 절에 명시된 순서대로 대이터를 정렬할 필요가 없다.
- 메모리 사용량을 줄이기 위해 파이프라인을 사용할 수 있는 조인과 달리, 정렬 작업은 첫 번째 결과 집합을 만들기 전에 완료해야 한다.
  - 파이프라인: 중간 결과 집합을 만드는 즉시 각 로우를 다음 조인 연산으로 넘김으로서 중간 결과 집합을 저장할 필요가 없게 된다.
- 인덱스를 사용하면 정렬 작업을 줄이고 모든 데이터를 처리하지 않고도 첫 번째 결과 집합을 반환할 수 있는 파이프라인 효과를 볼 수 있다.
  - 이런 효과를 내기 위해 `WHERE` 절에 사용할 인덱스 컬럼을 `ORDER BY` 절에서도 동일한 순서로 사용해야 한다.
  - 인덱스는 양방향으로 읽을 수 있기 때문에 `ORDER BY` 절에 명시된 것과 반대 방향으로 인덱스 범위를 스캔하더라도 파이프라인 효과를 볼 수 있다.

> MySQL 은 인덱스를 선언할 때 ASC 와 DESC 를 무시한다.

## 정리
- `WHERE` 절에 사용된 컬럼의 인덱스 유무는 쿼리 성능에 영향을 미친다.
- `SELECT` 절에 사용된 컬럼의 인덱스 유무 역시 쿼리 성능에 영향을 미칠 수 있다.
- 조인 조건에 사용된 컬럼의 인덱스 유무는 테이블 간 조인 성능에 영향을 미칠 수 있다.
- 인덱스는 `ORDER BY` 절의 효율에도 영향을 미칠 수 있다.
- 인덱스의 개수는 쓰기 작업에 영향을 미칠 수 있다.

## 인덱스 스캔, 테이블 스캔
- 쿼리를 만족하는 레코드를 정확히 짚어 내려고 인덱스를 사용하는 것을 인덱스 탐색이라고 한다.
- 적합한 레코드를 찾기 위해 인덱스를 스캔하는 것을 인덱스 스캔
- 데이터 페이지를 스캔하는 것을 테이블 스캔이라고 한다.

```sql
CREATE TABLE Customers
(
    CustomerID        int PRIMARY KEY NOT NULL,
    CustFirstName     varchar(25) NULL,
    CustLastName      varchar(25) NULL,
    CustStreetAddress varchar(50) NULL,
    CustCity          varchar(30) NULL,
    CustState         varchar(2) NULL,
    CustZipCode       varchar(10) NULL,
    CustAreaCode      smallint NULL,
    CustPhoneNumber   varchar(8) NULL
);

CREATE INDEX CustState ON Customers (CustState);
```
- 이 테이블엔 인덱스가 두 개이다.
  - `CustomerID` 는 기본키이기 때문에 인덱스가 자동으로 만들어지고, `CREATE INDEX` 문으로 `CustState` 컬럼에도 인덱스를 생성하였다.
- `SELECT * FROM Customers WHERE CustomerID = 1` 을 실행하면 기본키에서 유일 인덱스 탐색을 한 후 이 인덱스로 `Customers` 테이블에서 CustomerID = 1` 인 모든 데이터를 반환한다.
- `SELECT CustomerID FROM Customers WHERE CustomerID = 25` 를 실행하면 필요한 값이 모두 인덱스에 있으므로, 두 번째 단계는 불필요하게 테이블 데이터를 뒤져 보지 않고 유일 인덱스만 탐색한다.
- `SELECT * FROM Customers WHERE CustState = 'TX'` 의 경우 `CustState` 는 유일 인덱스가 아니기 때문에 `WHERE` 조건을 만족하는 모든 값을 찾기위해 인덱스 전체를 뒤져 봐야 한다.
  - 이후 테이블로 돌아가 데이터를 가져온다.
- `SELECT CustomerID FROM Customers WHERE CustAreaCode = '905'` 의 경우 `CustAreaCode` 컬럼에는 인덱스가 없으므로 테이블 스캔을 해야한다.
  - `CustAreaCode = '905'` 조건에 맞는 데이터를 찾기 위해 테이블에서 전체 로우를 뒤져야 한다.

## 인덱스
- 인덱스는 테이블에 비해 훨씬 작고 특별히 스캔용으로 설계된 객체이기 때문에 보통 테이블에 있는 소수의 로우만 검색할 때는 인덱스 스캔이 월등히 빠르다.
  - 테이블에서 인덱스가 33% 저도 차지하고 있다면 인덱스를 사용한다고 해서 큰 혜텍을 볼 수 없다.
- 인덱스는 데이터 추출 문제를 해결해주는 만능 해결사가 아니다.
  - 만은 인덱스가 데이터를 빠르게 가져오지도 않고 데이터 갱신 속도만 느리게 한다.
  - 인덱스 컬럼 하나를 갱신할 때마다 '인덱스 테이블'을 하나 이상 갱신하게 된다.
  - 이는 더 많은 디스크 읽기와 쓰기를 발생시킨다.
  - 인덱스를 생시하는 작업은 종종 테이블을 갱신하는 작업보다 비용이 많이 든다.
- 운영 목적의 테이블은 데이터 갱신 작업이 많기 때문에 이런 테이블에서 모든 인덱스를 면밀히 검토해야 한다.
  - 보고서용 테이블이 많은 데이터베이스(데이터 웨어하우스)는 갱신 작업이 많지 않기 때문에 인덱스 적용에 어울린다.
- 여러 `DBMS` 에서 사용하는 가장 흔한 인덱스 유형은 `B-tree` 인덱스이다.
- 인덱스를 만들 때는 컬럼의 조합도 중요하다.
  - 대부분의 쿼리에서 특정 컬럼들이 함께 사용된다면 인덱스에 컬럼들을 모두 포함해야 한다.
- 여러 컬럼으로 인덱스를 만들 때는 컬럼을 지정하는 순서가 중요하다.
  - 일부 쿼리는 `CustLastName` 컬럼의 특정 값을 찾고 다른 쿼리는 `CustFirstName` 과 `CustLastName` 의 특정 값을 찾는다면, 인덱스는 `CustLastName` , `CustFirstName` 순으로 만들어야 하고 반대로 만들면 안 된다.

### B-tree
- `B-tree` 는 루트 노드에서 시작해 많은 중간 노드를 거쳐 실제 데이터를 가리키는 수많은 리프 노드를 탐색하는 구조로 되어 있다.
- 쿼리 성능에 대한 `B-tree` 인덱스의 기여도는 인덱스 유형에 따라 크게 다르다.
  - 클러스터 인덱스와 비클러스터 인덱스가 있다.

#### 클러스터 인덱스
- 인덱스를 만들 때 명시된 컬럼의 순서대로 테이블의 데이터를 물리적으로 정렬한다.
- 테이블에 있는 로우를 두 가지 이상의 방식으로 정렬하는 것은 불가능하기에 클러스터 인덱스는 테이블당 하나만 만들 수 있다.
  - `SQL Server` 에서는 통상 클러스터 인덱스가 데이터를 직접 포함하는 리프 노드를 가진다.

#### 비클러스터 인덱스
- 비클러스터 인덱스는 클러스터 인덱스와 구조는 같다.
- 테이블 데이터가 쌓인 물리적인 순서와 다르게 정렬될 수 있다.
- 리프 노드는 데이터를 포함하지 않고 인덱스 키와 데이터를 가리키는 북마크로 구성된다.

### 성능
- 테이블 스캔보다 비클러스터 인덱스 스캔이 더 나은 성능을 발휘하는 여부는 테이블 크기, 로우의 저장 패턴, 로우의 길이, 쿼리가 반환하는 로우의 비율에 따라 다르다.
- 전체 로우 중 최소 10%의 로우가 반환될 때 테이블 스캔이 비클러스터 인덱스보다 더 나은 성능을 보이기 시작한다.
  - 클러스터 인덱스는 보통 반환되는 로우의 비율이 높을수록 테이블 스캔보다 나은 성능을 발휘한다.

### 데이터 접근 방식
- `WHERE` 절에서 사용되지 않는 컬럼을 인덱스로 만들면 큰 혜택을 볼 수 없다.
  - 컬럼의 카디널리티가 낮으면(인덱스 값의 다수가 같은 값일 때) 인덱스의 효과가 미미하다.
- 인덱스는 테이블이 클 때만 사용하는 것이 좋다.
  - 데이터베이스 엔진은 대부분 테이블이 작으면 그 데이터를 메모리에 올려놓는다.
  - '작다'의 기준은 로우의 개수, 개별 로우의 크기, 페이지에 로드되는 방식과 데이터베이스 서버의 가용 메모리 용량에 의존한다.

## 정리
- 적절한 인덱스를 만들도록 데이터를 분석해 성능을 향상한다.
- 생성한 인덱스가 실제로 잘 사용되는지 확인한다.

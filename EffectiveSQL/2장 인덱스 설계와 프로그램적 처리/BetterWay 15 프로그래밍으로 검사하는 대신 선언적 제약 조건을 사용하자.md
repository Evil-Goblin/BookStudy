## 제약 조건
- SQL 은 테이블 데이터 규칙을 명시하는 방식으로 제약 조건을 제공한다.
- `INSERT` , `DELETE` , `UPDATE` 작업이 일어날 때 모든 제약 조건이 검사된다.
  - 제약 조건 위배 시 해당 작업은 진행되지 않는다.

### 제약 조건 종류
- NOT NULL
  - 해당 컬럼에는 NULL 이 아닌 값만 입력된다.
- UNIQUE
  - 해당 컬럼에 중복 값이 입력되는 것을 방지한다.
  - NULL 을 허용한다.
- PRIMARY KEY
  - UNIQUE 제약 조건과 유사하다.
    - UNIQUE 제약 조건은 여러 개 만들 수 있지만, PRIMARY KEY 제약 조건은 한 개만 만들 수 있다.
  - 테이블의 각 레코드를 유일하게 식별한다.
  - NULL 을 방지한다.
- FOREIGN KEY
  - 한 테이블에 있는 외래키는 다른 테이블에 있는 기본키가 된다.
- CHECK
  - CHECK 제약 조건은 한 테이블이나 필드에 정의할 수 있다.
  - 단일 필드에 CHECK 제약 조건을 정의하면 이 필드에는 특정 값만 입력될 수 있다.
  - 테이블에 정의하면 특정 필드 값이 동일한 로우의 다른 필드 값을 기준으로 제한된다.
- DEFAULT
  - 한 필드의 기본 값을 정의하는 데 사용된다.
  - 새로운 로우를 입력할 때 해당 필드에 값을 입력하지 않으면 데이터베이스는 기본 값을 입력한다.

> DEFAULT 절은 제약 조건이 아니다.  
> 하지만 DEFAULT 절은 NOT NULL 제약 조건과 결합해 비즈니스 규칙을 강화하는 수단으로 사용할 수 있다.

### 절차적 참조 무결성
- 제약 조건을 사용해 DRI 가 제공하는 참조 무결성을 강화하는 다른 방법도 있다.
- 코드로 규칙을 검사하는 절차적 참조 무결성이 그중 하나이다.
- 절차적 참조 무결성을 구현하는 몇가지 메커니즘
  - 클라이언트 어플리케이션에서 작성한 코드
  - 저장 프로시저
  - 트리거
- 데이터베이스의 무결성을 강화하는 것과 관련된 모든 규칙을 처리하도록 프로그램 코드로 작성하는 것은 가능하지만 좋은 방법은 아니다.
  - 비즈니스 규칙과 데이터 간 관계를 관리하고 강화하는 것은 데이터 모델의 일부분이어야 한다.
  - 해당 역할을 어플리케이션이 아닌 데이터베이스에서 수행해야 한다.
  - 데이터를 한 가지 방식으로 갱신되게 하려면 데이터 규칙은 어플리케이션에 독립적이어야 한다.
- 저장 프로시저로 데이터 무결성을 강화하는 방법은 최소한 데이터베이스 내에서 규칙을 보존한다고 볼 수 있지만, 훨씬 어려운 접근 방법이다.
  - 특히 UPDATE 작업일 때 더욱 그렇다.
  - 저장 프로시저로 규칙을 강화할 수 있지만, 이 방법을 이용하면 사용자가 반드지 저장 프로시저로만 데이터를 수정해야 한다.
  - 이를 위해 사용자에게 해당 저장 프로시저의 실행 권한을 부여해야 하고, 주요 테이블에서는 데이터를 직접 갱신하지 못하게 하는 또 다른 차원의 작업이 필요하다.
- 참조 무결성을 강화하고 연속적으로 관련 작업을 수행하는 데 트리거를 사용할 수 있다.
  - 트리거는 일상적으로 사용하는 기준 테이블 데이터를 조작하는 것과 동일한 INSERT , UPDATE , DELETE 문을 사용할 수 있는 독립된 해결책이다.
  - 하지만 트리거를 사용할 때는 주의가 필요하다.

## 정리
- 제약 조건 사용을 검토해 데이터 무결성을 강화한다.
- 쿼리 옵티마이저는 고성능 쿼리 실행 계획을 만드는 데 제약 조건을 사용할 수 있다.

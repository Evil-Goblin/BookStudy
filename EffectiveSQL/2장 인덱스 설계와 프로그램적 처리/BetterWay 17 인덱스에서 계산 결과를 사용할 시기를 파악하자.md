## 계산 컬럼 인덱스
- 함수 기반의 계산 컬럼을 인덱스로 만드는 것이 가능하다.
  - DB2
    - 함수 기반 인덱스를 zOS 에서는 9 버전부터 지원한다.
    - LUW 에서는 10.5 버전부터 지원한다.
    - 사용자 정의 함수는 인덱스에서 사용할 수 없다.
    - 함수나 표현식의 결과를 저장하는 실제 컬럼을 만들고, 이 컬럼을 인덱스로 만드는 방식을 이용할 수 있다.
    - 이 새 컬럼은 인덱스로 만들 수 있고 `WHERE` 절에서도 표현식 없이 사용할 수 있다.
  - MySQL
    - 5.7 버전부터 다른 컬럼의 계산 결과 값을 저장하는 `GENERATED` 컬럼을 인덱스로 만들 수 있다.
    - 그 이전 버전은 DB2 에서 처리한 것과 같은 방식을 이용해야 한다.
  - Oracle
    - 8i 버전부터 함수 기반 인덱스를 지원한다.
    - 11g 버전부터는 가상 컬럼을 지원한다.
  - PostgreSQL
    - 7.4 버전부터 표현식에서 인덱스를 사용할 수 있다.
    - 7.2 버전부터는 부분적으로 지원한다.
  - SQL Server
    - 2000 버전부터 계산 커럼을 인덱스로 만들 수 있지만, 조건을 만족해야 한다.
      - 소유권 요구 사항
        - 계산 컬럼에 사용되는 모든 함수의 소유자는 테이블 소유자와 같아야 한다.
      - 결정성 요구 사항
        - 계산 컬럼은 결정적이어야 한다.
      - 정밀도 요구 사항
        - 함수에서는 `float` 나 `real` 데이터 타입의 표현식을 사용할 수 없고, 함수를 정의할 때도 `float` 나 `real` 데이터 타입을 사용할 수 없다.
      - 데이터 타입 요구 사항
        - text , ntext , image 타입을 사용할 수 없다.
      - SET 옵션 요구 사항
        - 계산 컬럼의 계산이 수행되는 내용을 정의하는 `CREATE TABLE` 문이나 `ALTER TABLE` 문이 실행될 때 `ANSI_NULLS` 연결 수준 옵션이 `ON` 으로 설정되어야 한다.

### 함수 기반 인덱스를 사용하는 이유
- 쿼리에서 대소문자를 처리하기 위함
  - Access, SQL Server, MySQL 은 대소문자를 구분하지 않는다.(MySQL 은 악센트도 구분하지 않는다.)

```sql
SELECT EmployeeID, EmpFirstName, EmpLastName
FROM Employees
WHERE EmpLastName = 'Viescas';
```
- 실제로 저장된 값이 'viescas', 'VIESCAS', 'Viescas', 'ViEsCaS' 더라도 동일한 사람을 결과로 반환한다.
  - 다른 DBMS 는 이름이 정확히 'Viescas' 로 입력된 사람만 찾는다.
  - 만약 대소문자 상관없이 결과를 얻으려면 `WHERE UPPER(EmpLastName) = 'VIESCAS'` 로 조회해야 한다.
- 이와 같이 `WHERE` 절에서 함수를 사용하는 쿼리는 인덱스로 쿼리 속도를 빠르게 하지 못하고 테이블 스캔이 수행된다.
  - 이 함수를 테이블에 있는 모든 로우에 적용해야 하기 때문

```sql
CREATE INDEX EmpLastNameUpper
    ON Employees (UPPER(EmpLastName));
```
- 이와 같이 인덱스를 만들면 인덱스 스캔을 수행하게 된다.

### 주의점
- 사용자 정의 함수를 사용한다면 해당 함수는 반드시 결정적 함수여야 한다.
  - 함수에서 직접적이든 간접적이든 현재 시간을 참조하는 함수를 인덱스로 만드는 것은 불가능하다.
- 비결정적 함수는 매번 다른 값이 반환될 수 있기 때문에 인덱스로 만들 수 없다.
- PostgreSQL , Oracle 에서는 결정적 함수를 정의할 때 반드시 `DETERMINISTIC(Oracle)` 이나 `IMMUTABLE(PostgreSQL)` 키워드를 명시해야 한다.
  - 이 키워드를 명시하면 개발자가 함수를 올바르게 선언했음을 신뢰하기 때문에 비결정적 함수를 결정적 함수로 선언해 인덱스 정의에 사용할 수 있다.
  - 하지만 결국 비결정적 함수이기 때문에 의도한 대로 동작하지 않을 것이다.
- 함수 기반 인덱스는 쿼리 최적화 관점에서 많은 이점이 있기에 극단적으로 모든 것을 인덱스로 만들어 사용할 여지가 있지만 이는 좋은 생각이 아니다.
  - 테이블에 인덱스가 많을 수록 UPDATE 작업이 느려지며, 함수 기반 인덱스는 중복 인덱스를 만들기가 쉽기 때문에 주의해야 한다.

## 정리
- 인덱스를 과다하게 만들지 않는다.
- 예상되는 데이터베이스 사용 실태를 분석해 필터링된 인덱스를 적합하게 사용하는지 확인한다.

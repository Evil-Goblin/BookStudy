## 구체화된 경로
- 개념적으로 파일 시스템 경로와 아무 차이가 없다.
  - 폴더와 파일 대신 기본키를 사용해 계층 정보를 훨씬 더 간단한 형태로 설명할 수 있다.

```sql
CREATE TABLE Employees
(
    EmployeeID    int PRIMARY KEY,
    EmpName       varchar(255) NOT NULL,
    EmpPosition   varchar(255) NOT NULL,
    SupervisorID  int NULL,
    HierarchyPath varchar(255)
);
```
- 구체화된 경로 모델에 필요한 메타데이터를 담은 추가 컬럼이 있는 테이블 생성 쿼리이다.

![구체환된_경로를_포함한_테이블](https://github.com/Evil-Goblin/BookStudy/assets/74400861/ccdc642c-40f4-4e08-8707-b70c3eabe8a0)
- 위 테이블을 조회한 결과이다.
- 이 방법에 보편적으로 준수해야 할 사항은 없다.
- 슬래시(/)는 기본키를 분리하는 최상의 구분자이다.
  - 저장 공간의 증가에 따른 비용은 발생하지만, 쿼리 단순화 측면에서는 루트 노드와 재귀 노드(Reflexive)[^1]를 모두 포함하는 쿼리를 만드는 것이 좋다.
  - 루트 노드와 재귀 노드를 빼는 것도 가능하지만, 빼게 되면 루트 노드나 표현하려는 레코드를 포함할 때 쿼리를 수정해야 한다.

```sql
SELECT e.*
FROM Employees AS e
WHERE e.HierarchyPath LIKE @NodePath + '%';
```
- 특정 노드의 모든 자식 노드를 찾는 쿼리이다.
- 'Tom LaPlante' 가 관리하는 직원을 모두 찾으려면 @NodePath 에 '1/2/'를 명시한다.
- 만약 성능이 걱정된다면 HierarchyPath 컬럼에 인덱스를 만들면 된다.
  - 이 쿼리에서는 문자열 끝에 '%'가 붙으므로 인덱스를 사용하게 되어 사거블 쿼리가 된다.

```sql
SELECT e.*
FROM Employees AS e
WHERE CHARINDEX(CONCAT('/', CAST(e.EmployeeID AS varchar(11)), '/'), @NodePath) > 0;
```
- 반대로 주어진 노드의 모든 조상을 찾는 쿼리이다.
- 안타깝게도 이 쿼리는 사거블 쿼리가 아니다.
- @NodePath 는 직원 자신의 경로를 참조한다.
  - 'Lee' 의 조상을 찾으려면 '1/2/5' 값을 입력해야 한다.
- 특히 중간이나 맨 아래에서 빠르고 광범위하게 탐색해야 한다면 구체화된 경로가 최적의 해결책이 아닐 수 있다.
- 가능한 옵션은 이 계층 구조를 반대 방향으로 저장해 놓은 컬럼을 만들고, 이 컬럼에 인덱스를 만드는 것이다.
  - 하지만 데이터와 인덱스 저장 용량을 고려하면 이 방법 역시 값비싼 비용이 든다.
- HierarchyPath 컬럼의 데이터 타입으로 varchar(255)를 사용하였다.
  - 대부분의 데이터베이스 엔진은 인덱스를 만들 수 있는 텍스트 컬럼의 문자 개수와 계층 정보 경로의 길이에 제한을 둔다.
  - 계층 정보가 너무 넓거나, 너무 깊은 경우 이런 제한을 위반할 수 있다.

## 정리
- 구체화된 경로는 파일 시스템과 같은 익숙한 방식을 사용하므로 이해하고 따라하기 쉽다는 장점이 있다.
- 계층 정보가 너무나 깊거나 넓어서 인덱스를 만들 때 문자 개수 제한에 걸리면 사전에 이를 감지해 처리하는 간단한 방법이 없으므로 설계의 제한 사항을 명확히 식별하기가 어렵다.
  - 따라서 이런 문제를 피할 수 있도록 계층 정보의 크기는 보수적으로 제한하는 것이 좋다.
- 구체화된 경로의 탐색은 한 방향에서만 효과적이다.
  - 검색 조건에서 '%'를 맨 끝이 아닌 처음이나 중간에 두면 사거블 쿼리를 만들 수 없기 때문이다.
  - 따라서 이점을 설계에 반영해야 한다.


[^1]: 재귀(Reflexive) 노드는 자기 자신을 가리키고, 재귀(Recursive) CTE 는 자기 자신 뿐만 아니라 '반복'의 의미도 포함되어 있다.

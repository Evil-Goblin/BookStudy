# 중첩 집합(Nested Set)
![중첩_집합_조직도](https://github.com/Evil-Goblin/BookStudy/assets/74400861/844800cb-3ae3-4631-8a4c-9a9b0ec2b7b9)
- 조직도를 중첩 집합으로 만든 그림이다.
- 왼쪽에서 오른쪽으로 가면서 자식 노드가 있을 때는 아래로, 더 이상 형제 노드가 없을 때는 다시 위로 올라간다.
  - 각 노드에는 숫자가 두 개 있고, 왼쪽은 초록색, 오른쪽은 빨간색으로 표시되어 있다.
- 이 조직도를 통해 다음을 유추할 수 있다.
  - 자식이 없는 노드의 왼쪽과 오른쪽 숫자의 차이는 1이다.
  - (오른쪽 숫자 - (왼쪽 숫자 + 1)) / 2 라는 공식으로 해당 노드의 하위 노드 개수를 구할 수 있다.
  - 특정 노드의 왼쪽과 오른 쪽 숫자 범위에 드는 왼쪽과 오른쪽 수를 가진 노드가 바로 이 노드의 자식 노드가 된다.
  - 마찬가지로 특정 노드의 왼쪽 숫자와 오른쪽 숫자 범위에 들지 않는 노드를 찾으면 부모 노드를 추적할 수 있다.

```sql
CREATE TABLE Employees
(
    EmployeeID   int PRIMARY KEY,
    EmpName      varchar(255) NOT NULL,
    EmpPosition  varchar(255) NOT NULL,
    SupervisorID int NULL,
    lft          int NULL,
    rgt          int NULL
);
```
- 중첩 집합의 데이블 생성 쿼리이다.
  - SQL 함수 LEFT(), RIGHT() 와 충돌하지 않도록 컬럼을 lft, rgt 라고 하였다.

```sql
SELECT e.*
FROM Employees AS e
WHERE e.lft >= @lft
  AND e.rgt <= @rgt;
```
- 주어진 노드의 자식 노드를 모두 찾는 쿼리이다.
- 잘못된 결과가 나오지 않게 하려면 lft 와 rgt 모두에 필터를 적용해야 한다.

```sql
SELECT *
FROM Employees AS e
WHERE e.lft <= @lft
  AND e.rgt >= @rgt;
```
- 반대로 주어진 노드의 조상을 모두 찾는 쿼리이다.
- 이 또한 특정 노드의 조상이 아닌 다른 부모 노드가 결과에 포함되지 않게 하기 위해 lft, rgt 모두에 필터를 적용했다.

### 중첩 집합 모델 단점
- 중첩 집합 모델의 가장 큰 단점은 계층 정보가 변경될 때이다.
  - 특히 한 브랜치(분기) 노드가 다른 브랜치 노드로 이동할 때 일관된 계층 정보를 유지하려면 테이블의 lft 와  rgt 메타데이터를 모두 갱신해야 한다.
- 계층 정보가 좀 더 자주 변경될 것 같다면 다른 접근법을 고려하는 것이 좋다.

## 정리
- 중첩 집합을 만들고 각 노드의 왼쪽과 오른쪽에 올바른 숫자를 할당하는 로직을 보이지 않게 수행하려면 저장 프로시저로 중첩 집합 모델을 관리해야 한다.
- 데이터를 자주 갱신할 때는 중첩 집합 모델이 적합하지 않다.
  - 빈번한 변경으로 테이블 전체에서 다른 노드의 숫자를 재계산해야 하기 때문이다.
  - 이때는 교착 상태에 빠지기 쉽다.
- 중첩 집합 모델을 이용하면 lft 와 rgt 메타데이터 컬럼으로 개수를 계산할 수 있어서 다른 레코드를 참조할 필요가 없으므로, 통계 정보를 매우 효율적으로 관리할 수 있다.
- 중첩 집합 모델은 단일 루트 노드를 가진 단일 계층 구조에서만 최적으로 수행된다.
  - 계층 구조가 여러 개여서 루트 노드도 여러 개일 때는 다른 모델 사용을 고려한다.
